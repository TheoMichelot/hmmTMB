% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hmm.R
\name{HMM}
\alias{HMM}
\title{R6 class for hidden Markov model}
\description{
R6 class for hidden Markov model

R6 class for hidden Markov model
}
\details{
Encapsulates the observation and hidden state models for a hidden
Markov model.

The forward-filtering backward-sampling algorithm returns a
sequence of states, similarly to the Viterbi algorithm, but it generates
it from the posterior distribution of state sequences, i.e., accounting
for uncertainty in the state classification. Multiple generated sequences
will therefore generally not be the same.


This is a wrapper around Observation$plot_dist, where the
distribution for each state is weighted by the proportion of time
spent in that state (according to the Viterbi state sequence).
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-HMM-new}{\code{HMM$new()}}
\item \href{#method-HMM-obs}{\code{HMM$obs()}}
\item \href{#method-HMM-hidden}{\code{HMM$hidden()}}
\item \href{#method-HMM-out}{\code{HMM$out()}}
\item \href{#method-HMM-tmb_obj}{\code{HMM$tmb_obj()}}
\item \href{#method-HMM-tmb_obj_joint}{\code{HMM$tmb_obj_joint()}}
\item \href{#method-HMM-tmb_rep}{\code{HMM$tmb_rep()}}
\item \href{#method-HMM-states}{\code{HMM$states()}}
\item \href{#method-HMM-coeff_fe}{\code{HMM$coeff_fe()}}
\item \href{#method-HMM-coeff_re}{\code{HMM$coeff_re()}}
\item \href{#method-HMM-fixpar}{\code{HMM$fixpar()}}
\item \href{#method-HMM-lambda}{\code{HMM$lambda()}}
\item \href{#method-HMM-update_par}{\code{HMM$update_par()}}
\item \href{#method-HMM-sd_re}{\code{HMM$sd_re()}}
\item \href{#method-HMM-par}{\code{HMM$par()}}
\item \href{#method-HMM-suggest_initial}{\code{HMM$suggest_initial()}}
\item \href{#method-HMM-set_priors}{\code{HMM$set_priors()}}
\item \href{#method-HMM-priors}{\code{HMM$priors()}}
\item \href{#method-HMM-iters}{\code{HMM$iters()}}
\item \href{#method-HMM-out_stan}{\code{HMM$out_stan()}}
\item \href{#method-HMM-llk}{\code{HMM$llk()}}
\item \href{#method-HMM-edf}{\code{HMM$edf()}}
\item \href{#method-HMM-setup}{\code{HMM$setup()}}
\item \href{#method-HMM-fit_stan}{\code{HMM$fit_stan()}}
\item \href{#method-HMM-fit}{\code{HMM$fit()}}
\item \href{#method-HMM-mle}{\code{HMM$mle()}}
\item \href{#method-HMM-forward_backward}{\code{HMM$forward_backward()}}
\item \href{#method-HMM-cond}{\code{HMM$cond()}}
\item \href{#method-HMM-pseudores}{\code{HMM$pseudores()}}
\item \href{#method-HMM-viterbi}{\code{HMM$viterbi()}}
\item \href{#method-HMM-sample_states}{\code{HMM$sample_states()}}
\item \href{#method-HMM-state_probs}{\code{HMM$state_probs()}}
\item \href{#method-HMM-post_coeff}{\code{HMM$post_coeff()}}
\item \href{#method-HMM-post_linpred}{\code{HMM$post_linpred()}}
\item \href{#method-HMM-post_fn}{\code{HMM$post_fn()}}
\item \href{#method-HMM-predict}{\code{HMM$predict()}}
\item \href{#method-HMM-simulate}{\code{HMM$simulate()}}
\item \href{#method-HMM-gof}{\code{HMM$gof()}}
\item \href{#method-HMM-plot_ts}{\code{HMM$plot_ts()}}
\item \href{#method-HMM-plot_dist}{\code{HMM$plot_dist()}}
\item \href{#method-HMM-plot}{\code{HMM$plot()}}
\item \href{#method-HMM-AIC_marginal}{\code{HMM$AIC_marginal()}}
\item \href{#method-HMM-AIC_conditional}{\code{HMM$AIC_conditional()}}
\item \href{#method-HMM-print_obspar}{\code{HMM$print_obspar()}}
\item \href{#method-HMM-print_tpm}{\code{HMM$print_tpm()}}
\item \href{#method-HMM-formulation}{\code{HMM$formulation()}}
\item \href{#method-HMM-print}{\code{HMM$print()}}
\item \href{#method-HMM-clone}{\code{HMM$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-new"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-new}{}}}
\subsection{Method \code{new()}}{
Create new HMM object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$new(obs = NULL, hidden = NULL, file = NULL, init = NULL, fixpar = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{obs}}{Observation object}

\item{\code{hidden}}{MarkovChain object}

\item{\code{file}}{path to specification file for HMM}

\item{\code{init}}{HMM object to initialize parameters with}

\item{\code{fixpar}}{a named list of parameters in coeff_fe that you want fixed 
(set to NA) or pool into common values (using factor levels)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new HMM object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-obs"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-obs}{}}}
\subsection{Method \code{obs()}}{
Observation object for this model
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$obs()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-hidden"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-hidden}{}}}
\subsection{Method \code{hidden()}}{
MarkovChain object for this model
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$hidden()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-out"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-out}{}}}
\subsection{Method \code{out()}}{
Output of optimiser after model fitting
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$out()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-tmb_obj"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-tmb_obj}{}}}
\subsection{Method \code{tmb_obj()}}{
Model object created by TMB. This is the output of 
the TMB function \code{MakeADFun}, and it is a list including elements
\itemize{
  \item{\code{fn}}{Objective function}
  \item{\code{gr}}{Gradient function of fn}
  \item{\code{par}}{Vector of initial parameters on working scale}
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$tmb_obj()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-tmb_obj_joint"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-tmb_obj_joint}{}}}
\subsection{Method \code{tmb_obj_joint()}}{
Model object created by TMB for the joint likelihood of
the fixed and random effects. This is the output of the TMB function 
\code{MakeADFun}, and it is a list including elements
\itemize{
  \item{\code{fn}}{Objective function}
  \item{\code{gr}}{Gradient function of fn}
  \item{\code{par}}{Vector of initial parameters on working scale}
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$tmb_obj_joint()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-tmb_rep"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-tmb_rep}{}}}
\subsection{Method \code{tmb_rep()}}{
Output of the TMB function \code{sdreport}, which includes 
estimates and standard errors for all model parameters.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$tmb_rep()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-states"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-states}{}}}
\subsection{Method \code{states()}}{
Vector of estimated states, after \code{viterbi} has
been run
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$states()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-coeff_fe"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-coeff_fe}{}}}
\subsection{Method \code{coeff_fe()}}{
Coefficients for fixed effect parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$coeff_fe()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-coeff_re"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-coeff_re}{}}}
\subsection{Method \code{coeff_re()}}{
Coefficients for random effect parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$coeff_re()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-fixpar"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-fixpar}{}}}
\subsection{Method \code{fixpar()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$fixpar()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-lambda"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-lambda}{}}}
\subsection{Method \code{lambda()}}{
Smoothness parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$lambda()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-update_par"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-update_par}{}}}
\subsection{Method \code{update_par()}}{
Update parameters stored inside model object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$update_par(par_list = NULL, iter = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{par_list}}{a list for coeff_f(r)e_obs, coeff_f(r)e_hid, log_delta, 
log_lambda_hid log_lambda_obs}

\item{\code{iter}}{Optional argument to update model parameters based on MCMC
iterations (if using rstan). Either the index of the iteration to use,
or "mean" if the posterior mean should be used.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-sd_re"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-sd_re}{}}}
\subsection{Method \code{sd_re()}}{
Standard deviation of smooth terms (or random effects)

This function transforms the smoothness parameter of
each smooth term into a standard deviation, given by 
SD = 1/sqrt(lambda). It is particularly helpful to get the
standard deviations of independent normal random effects.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$sd_re()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
List of standard deviations for observation model and
hidden state model.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-par"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-par}{}}}
\subsection{Method \code{par()}}{
Model parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$par(t = 1)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{t}}{returns parameters at time t, default is t = 1}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with elements:
\itemize{
  \item{\code{obspar}}{Parameters of observation model}
  \item{\code{tpm}}{Transition probability matrix of hidden state model}
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-suggest_initial"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-suggest_initial}{}}}
\subsection{Method \code{suggest_initial()}}{
Suggest initial observation parameters

The K-means algorithm is used to define clusters of observations
(supposed to approximate the HMM states). Then, for each cluster,
the \code{parapprox} function of the relevant \code{Dist} object
is used to obtain parameter values.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$suggest_initial()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
List of initial parameters for each observation variable
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-set_priors"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-set_priors}{}}}
\subsection{Method \code{set_priors()}}{
Set priors for coefficients
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$set_priors(new_priors = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{new_priors}}{is a list of matrices for optionally 
coeff_fe_obs, coeff_fe_hid, log_lambda_obs log_lambda_hid 
each matrix has two rows (first row = mean, second row = sd) 
specifying parameters for Normal priors}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-priors"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-priors}{}}}
\subsection{Method \code{priors()}}{
Extract stored priors
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$priors()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-iters"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-iters}{}}}
\subsection{Method \code{iters()}}{
Iterations from stan MCMC fit
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$iters(type = "response")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{Either "response" for parameters on the response (natural)
scale, or "raw" for parameters on the linear predictor scale.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
see output of as.matrix in stan
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-out_stan"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-out_stan}{}}}
\subsection{Method \code{out_stan()}}{
fitted stan object from MCMC fit
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$out_stan()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
the stanfit object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-llk"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-llk}{}}}
\subsection{Method \code{llk()}}{
Log-likelihood at current parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$llk()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Log-likelihood
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-edf"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-edf}{}}}
\subsection{Method \code{edf()}}{
Effective degrees of freedom
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$edf()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Number of effective degrees of freedom
(accounting for flexibility in non-parametric 
terms implied by smoothing)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-setup"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-setup}{}}}
\subsection{Method \code{setup()}}{
TMB setup

This creates an attribute \code{tmb_obj}, which can be used to 
evaluate the negative log-likelihood function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$setup(silent = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{silent}}{Logical. If TRUE, all tracing outputs are hidden (default).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-fit_stan"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-fit_stan}{}}}
\subsection{Method \code{fit_stan()}}{
Fit model using tmbstan

Consult documentation of the tmbstan package for more information.
After this method has been called, the Stan output can be accessed
using the method \code{out_stan()}. This Stan output can for example 
be visualised using functions from the rstan package. The parameters
stored in this HMM object are automatically updated to the mean 
posterior estimate, although this can be changed using 
\code{update_par()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$fit_stan(..., silent = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{Arguments passed to tmbstan}

\item{\code{silent}}{Logical. If FALSE, all tracing outputs are shown (default).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-fit"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-fit}{}}}
\subsection{Method \code{fit()}}{
Model fitting

The negative log-likelihood of the model is minimised using the
function \code{optim}. TMB uses the Laplace approximation to integrate 
the random effects out of the likelihood.

After the model has been fitted, the output of \code{optim} can be
accessed using the method \code{out}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$fit(silent = FALSE, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{silent}}{Logical. If FALSE, all tracing outputs are hidden (default).}

\item{\code{...}}{other arguments to optimx which is used to optimise likelihood, 
see ?optimx}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-mle"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-mle}{}}}
\subsection{Method \code{mle()}}{
Get maximum likelihood estimates once model fitted
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$mle()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
list of maximum likelihood estimates as described as
input for the function update_par()
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-forward_backward"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-forward_backward}{}}}
\subsection{Method \code{forward_backward()}}{
Forward-backward algorithm 

The forward probability for time step t and state j 
is the joint pdf/pmf of observations up to time t and of being in
state j at time t, p(Z[1], Z[2], ..., Z[t], S[t] = j).
The backward probability for time t and state j is the
conditional pdf/pmf of observations between time t + 1 and n,
given state j at time t, p(Z[t+1], Z[t+2], ..., Z[n] | S[t] = j).
This function returns their logarithm, for use in other methods
\code{state_probs}, and \code{sample_states}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$forward_backward()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Log-forward and log-backward probabilities
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-cond"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-cond}{}}}
\subsection{Method \code{cond()}}{
Compute conditional cumulative distribution functions
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$cond(ngrid = 1000, silent = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ngrid}}{how many cells on the grid that CDF is computed on}

\item{\code{silent}}{if TRUE then no messages are printed}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
cdfs on grid for each variable
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-pseudores"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-pseudores}{}}}
\subsection{Method \code{pseudores()}}{
Pseudo-residuals

Compute pseudo-residuals for the fitted model. If the fitted model
is the "true" model, the pseudo-residuals follow a standard normal distribution.
Deviations from normality suggest lack of fit.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$pseudores()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Matrix of pseudo-residuals, with one row for each response variable
and one column for each observation
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-viterbi"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-viterbi}{}}}
\subsection{Method \code{viterbi()}}{
Viterbi algorithm
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$viterbi()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Most likely state sequence
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-sample_states"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-sample_states}{}}}
\subsection{Method \code{sample_states()}}{
Sample posterior state sequences using forward-filtering
backward-sampling
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$sample_states(nsamp = 1, full = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{nsamp}}{Number of samples to produce}

\item{\code{full}}{If TRUE and model fit by fit_stan then parameter estimates are 
sampled from the posterior samples before simulating each sequence}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Matrix where each column is a different sample of state sequences,
and each row is a time of observation
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-state_probs"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-state_probs}{}}}
\subsection{Method \code{state_probs()}}{
Compute posterior probability of being in each state
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$state_probs()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
matrix with a row for each observation and a column for each state
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-post_coeff"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-post_coeff}{}}}
\subsection{Method \code{post_coeff()}}{
Posterior sampling for model coefficients
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$post_coeff(n_post)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n_post}}{Number of posterior samples}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Matrix with one column for each coefficient and one row
for each posterior draw
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-post_linpred"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-post_linpred}{}}}
\subsection{Method \code{post_linpred()}}{
Posterior sampling for linear predictor
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$post_linpred(n_post)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n_post}}{Number of posterior samples}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Matrix with one column for each predictor and one row
for each posterior draw
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-post_fn"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-post_fn}{}}}
\subsection{Method \code{post_fn()}}{
Create posterior simulations of a function of a model component
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$post_fn(fn, n_post, comp = NULL, ..., level = 0)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fn}}{the function which takes a vector of linear predictors as input
and produces either a scalar or vector output}

\item{\code{n_post}}{number of posterior simulations}

\item{\code{comp}}{is "obs" for observation model linear predictor, "hidden" for
hidden model linear predictor}

\item{\code{...}}{arguments passed to fn}

\item{\code{level}}{confidence interval level, default is 95\%}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a vector (for scalar outputs of fn) or a matrix (for vector outputs)
with a column for each simulation
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-predict"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-predict}{}}}
\subsection{Method \code{predict()}}{
Predict estimates from a fitted model
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$predict(name, t = 1, newdata = NULL, level = 0.95, n_post = 0)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{Which estimates to predict? Options include 
transition probability matrices "tpm", 
stationary distributions "delta", or 
observation distribution parameters "obspar"}

\item{\code{t}}{Time points to predict at}

\item{\code{newdata}}{New dataframe to use for prediction}

\item{\code{level}}{Level of the confidence intervals, e.g. CI = 0.95
will produce 95\% confidence intervals (default)}

\item{\code{n_post}}{If greater than zero then n_post posterior 
samples are produced}

\item{\code{...}}{Other arguments to the respective functions 
for hidden$tpm, hidden$delta, obs$par}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Named array of predictions and confidence interval, 
if requested
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-simulate"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-simulate}{}}}
\subsection{Method \code{simulate()}}{
Simulate from hidden Markov model
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$simulate(n, data = NULL, silent = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{Number of time steps to simulate}

\item{\code{data}}{Optional data frame including covariates}

\item{\code{silent}}{if TRUE then no messages are printed}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Data frame including columns of data (if provided), and simulated
data variables
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-gof"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-gof}{}}}
\subsection{Method \code{gof()}}{
Compute goodness-of-fit statistics using simulation
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$gof(gof_fn, nsims = 100, full = FALSE, silent = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{gof_fn}}{goodness-of-fit function which accepts "data" as input
and returns a statistic: either a vector or a single number.}

\item{\code{nsims}}{number of simulations to perform}

\item{\code{full}}{if model fit with MCMC then full set to TRUE will sample from
posterior for each simulation}

\item{\code{silent}}{Logical. If FALSE, simulation progress is shown. 
(Default: TRUE)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
List with elements:
\itemize{
  \item{obs_stat}{Vector of values of goodness-of-fit statistics for the
  observed data}
  \item{stats}{Matrix of values of goodness-of-fit statistics for the
  simulated data sets (one row for each statistic, and one column for each
  simulation)}
  \item{plot}{ggplot object}
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-plot_ts"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-plot_ts}{}}}
\subsection{Method \code{plot_ts()}}{
Time series plot coloured by states

Creates a plot of the data coloured by the most likely state sequence,
as estimated by the Viterbi algorithm. If one variable name is passed
as input, it is plotted against time. If two variables are passed, they
are plotted against each other.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$plot_ts(var1, var2 = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{var1}}{Name of the variable to plot.}

\item{\code{var2}}{Optional name of a second variable, for 2-d plot.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A ggplot object
Plot observation distributions weighted by frequency in Viterbi
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-plot_dist"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-plot_dist}{}}}
\subsection{Method \code{plot_dist()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$plot_dist(name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{Name of data variable}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Plot of distribution with data histogram
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-plot"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-plot}{}}}
\subsection{Method \code{plot()}}{
Plot a model component
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$plot(
  name,
  var = NULL,
  covs = NULL,
  i = NULL,
  j = NULL,
  n_grid = 50,
  n_post = 1000
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{name of model component: tpm, delta, or obspar}

\item{\code{var}}{name of covariate to plot on x-axis}

\item{\code{covs}}{Optional named list for values of covariates (other than 'var') 
that should be used in the plot (or dataframe with single row). If this is
not specified, the mean value is used for numeric variables, and the
first level for factor variables.}

\item{\code{i}}{if plotting tpm then rows of tpm, if plotting delta then state, 
if plotting obspar then indices of parameter to plot}

\item{\code{j}}{if plotting tpm then cols of tpm to plot, if plotting delta then
ignored, if plotting obspar then indices of states to plot}

\item{\code{n_grid}}{coarseness of grid over x-axis to create}

\item{\code{n_post}}{Number of posterior simulations to use when computing
confidence intervals; default: 1000. If set to 0, confidence intervals
are derived using the delta method rather than simulations. See 
\code{predict} function for more detail.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A ggplot object 
Marginal Akaike Information Criterion

The marginal AIC is for example defined by 
Wood (2017), as AIC = - 2L + 2k where L is the
maximum marginal log-likelihood (of fixed 
effects), and k is the number of degrees
of freedom of the fixed effect component of
the model
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-AIC_marginal"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-AIC_marginal}{}}}
\subsection{Method \code{AIC_marginal()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$AIC_marginal()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Marginal AIC
Conditional Akaike Information Criterion

The conditional AIC is for example defined by 
Wood (2017), as AIC = - 2L + 2k where L is the
maximum joint log-likelihood (of fixed and random
effects), and k is the number of effective degrees
of freedom of the model (accounting for flexibility
in non-parametric terms implied by smoothing)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-AIC_conditional"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-AIC_conditional}{}}}
\subsection{Method \code{AIC_conditional()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$AIC_conditional()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Conditional AIC
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-print_obspar"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-print_obspar}{}}}
\subsection{Method \code{print_obspar()}}{
Print observation parameters at t = 1
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$print_obspar()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-print_tpm"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-print_tpm}{}}}
\subsection{Method \code{print_tpm()}}{
Print observation parameters at t = 1
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$print_tpm()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-formulation"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-formulation}{}}}
\subsection{Method \code{formulation()}}{
Print model formulation
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$formulation()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-print"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-print}{}}}
\subsection{Method \code{print()}}{
Print HMM object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$print()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-HMM-clone"></a>}}
\if{latex}{\out{\hypertarget{method-HMM-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
