% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/forecast.R
\name{Forecast}
\alias{Forecast}
\title{R6 Class for Forecast in Hidden Markov Models}
\description{
Creates a forecast object from a fitted HMM model, projecting future state probabilities and unconditional observation densities for a user-defined horizon using a covariate data-frame if applicable. Forecasting occurs in the constructor; results are accessible via public methods.
}
\examples{

## ------------------------------------------------
## Method `Forecast$new`
## ------------------------------------------------

\dontrun{
data(faithful)

# Create training and forecast data frames
training_fraction <- 0.8
n_training <- floor(nrow(faithful) * training_fraction)
training_df <- data.frame(
  ID = rep(1, n_training),
  waiting = faithful$waiting[1:n_training],
  eruptions = faithful$eruptions[1:n_training]
)
forecast_df <- data.frame(
  ID = rep(1, nrow(faithful) - n_training),
  waiting = faithful$waiting[(n_training + 1):nrow(faithful)],
  eruptions = faithful$eruptions[(n_training + 1):nrow(faithful)]
)
# Create 2-state model with non-linear effect of waiting on all transitions
hid_model <- MarkovChain$new(
  data = training_df,
  n_states = 2,
  formula = ~ s(waiting, k = 10, bs = "cs")
)

# Create observation model with normal distribution for duration
obs_model <- Observation$new(
  data = training_df,
  n_states = 2,
  dists = list(eruptions = "norm"),
  par = list(eruptions = list(
    mean = c(0, 0),
    sd = c(1, 1)
  ))
)
# Update model parameters to suggested
obs_model$update_par(par = obs_model$suggest_initial())
# Create HMM model
hmm <- HMM$new(
  hid = hid_model,
  obs = obs_model
)
hmm$fit(silent = TRUE)
# Create forecast object
forecast <- Forecast$new(
  hmm = hmm,
  forecast_data = forecast_df,
  starting_state_distribution = "last"
  )
}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-Forecast-new}{\code{Forecast$new()}}
\item \href{#method-Forecast-obs_par_forecast}{\code{Forecast$obs_par_forecast()}}
\item \href{#method-Forecast-tpm_forecast}{\code{Forecast$tpm_forecast()}}
\item \href{#method-Forecast-eval_range}{\code{Forecast$eval_range()}}
\item \href{#method-Forecast-forecast_data}{\code{Forecast$forecast_data()}}
\item \href{#method-Forecast-update_eval_range}{\code{Forecast$update_eval_range()}}
\item \href{#method-Forecast-hidden_state_forecast}{\code{Forecast$hidden_state_forecast()}}
\item \href{#method-Forecast-forecast_dists}{\code{Forecast$forecast_dists()}}
\item \href{#method-Forecast-clone}{\code{Forecast$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Forecast-new"></a>}}
\if{latex}{\out{\hypertarget{method-Forecast-new}{}}}
\subsection{Method \code{new()}}{
Construct a forecast object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Forecast$new(
  hmm = NULL,
  n = NULL,
  forecast_data = NULL,
  preset_eval_range = NULL,
  starting_state_distribution = "last"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{hmm}}{A fitted HMM object.}

\item{\code{n}}{Integer. Forecast horizon (ignored if forecast_data provided).}

\item{\code{forecast_data}}{data.frame of future covariates / IDs.
Must include all covariates in fitted hmm.}

\item{\code{preset_eval_range}}{Named list: elements are numeric vectors (univariate) or matrices
(multivariate, rows as dimension ex. mu1, mu2, columns as points).
Missing entries default to 90–110% range of training data.}

\item{\code{starting_state_distribution}}{Numeric vector of length nstates(), or
"last" (Fitted model at final training row, propagated one step) or
"stationary" (model’s stationary distribution).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Algorithm overview
\enumerate{
  \item Validate inputs (private$validate_params()).
  \item Build or accept future design matrix (forecast_data).
  \item Obtain time-varying transition matrices (tpm_forecast) and
        observation parameters (obs_par_forecast) via hmm$predict().
  \item Forward-propagate hidden-state distribution (hidden_state_forecast).
  \item Marginalise over states for unconditional pdfs on user-defined grid (forecast_dists).
}
}

\subsection{Returns}{
An R6 object with notable public accessor methods (invoke with ()):
\describe{
  \item{hidden_state_forecast}{nstates × n forecast steps.}
  \item{obs_par_forecast}{Array of time-varying observation parameters.}
  \item{tpm_forecast}{Array of time-varying transition matrices.}
  \item{forecast_dists}{List of unconditional pdf matrices, one per observation variable.}
  \item{eval_range}{List of grids on which each pdf was evaluated.}
}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{\dontrun{
data(faithful)

# Create training and forecast data frames
training_fraction <- 0.8
n_training <- floor(nrow(faithful) * training_fraction)
training_df <- data.frame(
  ID = rep(1, n_training),
  waiting = faithful$waiting[1:n_training],
  eruptions = faithful$eruptions[1:n_training]
)
forecast_df <- data.frame(
  ID = rep(1, nrow(faithful) - n_training),
  waiting = faithful$waiting[(n_training + 1):nrow(faithful)],
  eruptions = faithful$eruptions[(n_training + 1):nrow(faithful)]
)
# Create 2-state model with non-linear effect of waiting on all transitions
hid_model <- MarkovChain$new(
  data = training_df,
  n_states = 2,
  formula = ~ s(waiting, k = 10, bs = "cs")
)

# Create observation model with normal distribution for duration
obs_model <- Observation$new(
  data = training_df,
  n_states = 2,
  dists = list(eruptions = "norm"),
  par = list(eruptions = list(
    mean = c(0, 0),
    sd = c(1, 1)
  ))
)
# Update model parameters to suggested
obs_model$update_par(par = obs_model$suggest_initial())
# Create HMM model
hmm <- HMM$new(
  hid = hid_model,
  obs = obs_model
)
hmm$fit(silent = TRUE)
# Create forecast object
forecast <- Forecast$new(
  hmm = hmm,
  forecast_data = forecast_df,
  starting_state_distribution = "last"
  )
}
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Forecast-obs_par_forecast"></a>}}
\if{latex}{\out{\hypertarget{method-Forecast-obs_par_forecast}{}}}
\subsection{Method \code{obs_par_forecast()}}{
Get predicted observation parameters.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Forecast$obs_par_forecast()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Forecast-tpm_forecast"></a>}}
\if{latex}{\out{\hypertarget{method-Forecast-tpm_forecast}{}}}
\subsection{Method \code{tpm_forecast()}}{
Get predicted transition matrices.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Forecast$tpm_forecast()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Forecast-eval_range"></a>}}
\if{latex}{\out{\hypertarget{method-Forecast-eval_range}{}}}
\subsection{Method \code{eval_range()}}{
Get the evaluation grid for each response variable.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Forecast$eval_range()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Forecast-forecast_data"></a>}}
\if{latex}{\out{\hypertarget{method-Forecast-forecast_data}{}}}
\subsection{Method \code{forecast_data()}}{
Get the forecast data used for predictions.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Forecast$forecast_data()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Forecast-update_eval_range"></a>}}
\if{latex}{\out{\hypertarget{method-Forecast-update_eval_range}{}}}
\subsection{Method \code{update_eval_range()}}{
Update the evaluation grid for forecast pdfs.
This method reconfigures the evaluation range used to compute unconditional predictive pdfs.
It validates the new eval_range, updates internal state, reinitializes forecast densities,
and returns the object invisibly for chaining.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Forecast$update_eval_range(eval_range)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{eval_range}}{A named list specifying the new evaluation grid for each observation variable.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
The Forecast object (invisibly), allowing method chaining.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Forecast-hidden_state_forecast"></a>}}
\if{latex}{\out{\hypertarget{method-Forecast-hidden_state_forecast}{}}}
\subsection{Method \code{hidden_state_forecast()}}{
Get the forward state probabilities.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Forecast$hidden_state_forecast()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Forecast-forecast_dists"></a>}}
\if{latex}{\out{\hypertarget{method-Forecast-forecast_dists}{}}}
\subsection{Method \code{forecast_dists()}}{
Get the unconditional predictive pdfs.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Forecast$forecast_dists()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Forecast-clone"></a>}}
\if{latex}{\out{\hypertarget{method-Forecast-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Forecast$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
